mean((Opt_scsd$theta-repar_theta)^2)
# test <- Opt
# #ncl(par_init, dt, X, T)
# Opt_u$theta
# test$theta
# sum(Opt_scsd$fit$weights[[2]]!=0)
# sum(Opt_scsd$fit$weights[[2]] == Opt_scsd$fit$weights[[3]])
# which(Opt_scsd$fit$weights[[2]]!=0, arr.ind = T)
# which(Opt_scsd$fit$weights[[4]]!=0, arr.ind = T)
# Opt_gd <- fit_gammaFrailty(
#     DATA_LIST = list('DATA' = dt, 'X' = X),
#     METHOD = 'GD',
#     CPP_CONTROL = ctrl_gd,
#     VERBOSEFLAG= 0,
#     INIT = par_init,
#     ITERATIONS_SUBSET = trajSub
# )
# mean((repartopar(Opt_gd$theta)-theta)^2)
# sampleVar(
#     THETA = Opt_sgd$theta,
#     DATA = dt,
#     X = X,
#     NU = 1,
#     METHOD = 1,
#     RANGE = ctrl_scsd$MAXT-ctrl_scsd$BURN,
#     TOTFLAG = T,
#     PRINTFLAG = F
# )
#
# #### check hessian ####
# Rwrapper_ncl <- function(par){
#     ncl(par, dt, X)$nll
# }
# Rwrapper_ngr <- function(par){
#     ncl(par, dt, X)$ngradient
# }
#
# chosen_par <- Opt_sgd$fit$path_av_theta[1001,]#Opt_u$theta#par_init #
# chosen_par <- par_init
# chosen_par <- Opt_u$theta
#
# H <- sampleH(chosen_par, dt, X, INVERTFLAG = F)
# Hnum <- numDeriv::jacobian(Rwrapper_ngr, chosen_par)
# H2 <- H
# diag(H2) <- diag(Hnum)
# diag(H)
# diag(Hnum)
# Hnum %>% solve() %>% diag() %>% round(4)
# H2 %>% solve() %>% diag() %>% round(4)
# H %>% solve() %>% diag() %>% round(4)
#
# it <- 5000
# sgd_se <- sampleVar(
#     THETA = Opt_sgd$fit$path_av_theta[it,],
#     DATA = dt,
#     X = X,
#     NU = 1,
#     METHOD = 1,
#     RANGE = it-ctrl_scsd$BURN,
#     TOTFLAG = T,
#     PRINTFLAG = F
# )
#
# scsd_se <- sampleVar(
#     THETA = Opt_scsd$fit$path_av_theta[it,],
#     DATA = dt,
#     X = X,
#     NU = 1,
#     METHOD = 2,
#     RANGE = it-ctrl_scsd$BURN,
#     TOTFLAG = T,
#     PRINTFLAG = F
# )
# sgd_se$se$se_stoc
# scsd_se$se$se_stoc
#
# Hinv <- sampleH(Opt_scsd$fit$path_av_theta[it,], dt, X, INVERTFLAG = T)
# J <- sampleJ(Opt_scsd$fit$path_av_theta[it,], dt, X)
# (Hinv%*%J%*%Hinv/(it-ctrl_scsd$BURN)) %>% diag() %>% sqrt()
# (Hinv/(it-ctrl_scsd$BURN)) %>% diag() %>% sqrt()
# scsd_se$var$var_stoc %>% diag() %>% sqrt()
# H %>%  diag(); (scsd_se$var$var_stoc * (it-ctrl_scsd$BURN)) %>% diag()
# diag(J);diag(Hinv); diag(solve(Hinv))
gg <- get_tidy_path(Opt_sgd, 'path_av_theta', F) %>%
mutate( mod = 'SGD') %>%
bind_rows(
get_tidy_path(Opt_scsd, 'path_av_theta', F) %>%
mutate( mod = 'SCSD')
) %>%
mutate(
mse = map_dbl(path_av_theta, ~mean((.x-repar_theta)^2))
) %>%
ggplot( aes(x = iter, y = log(mse), col = mod))+
geom_line()+
geom_hline(yintercept = log(mean((Opt_u$theta-repar_theta)^2)), linetype = 'dashed')+
theme_minimal()
plotly::ggplotly(gg)
ctrl_sgd <- list(
MAXT = 6000,
BURN = 200,
STEPSIZE = .004,
#STEPSIZE0 = .0005,
NU = 1,
SEED = seed
)
Opt_sgd <- fit_gammaFrailty(
DATA_LIST = list('DATA' = dt, 'X' = X),
METHOD = 'SGD',
CPP_CONTROL = ctrl_sgd,
VERBOSEFLAG= 0,
INIT = par_init,
ITERATIONS_SUBSET = NULL#trajSub
)
mean((repartopar(Opt_sgd$theta)-theta)^2)
mean((Opt_sgd$theta-repar_theta)^2)
ctrl_scsd <- list(
MAXT = 6000,
BURN = 200,
STEPSIZE = .004,
#STEPSIZE0 = .0005,
NU = 1,
SEED = seed
)
Opt_scsd <- fit_gammaFrailty(
DATA_LIST = list('DATA' = dt, 'X' = X),
METHOD = 'SCSD',
CPP_CONTROL = ctrl_scsd,
VERBOSEFLAG= 0,
INIT = par_init,
ITERATIONS_SUBSET = NULL
)
mean((repartopar(Opt_scsd$theta)-theta)^2)
mean((Opt_scsd$theta-repar_theta)^2)
# test <- Opt
# #ncl(par_init, dt, X, T)
# Opt_u$theta
# test$theta
# sum(Opt_scsd$fit$weights[[2]]!=0)
# sum(Opt_scsd$fit$weights[[2]] == Opt_scsd$fit$weights[[3]])
# which(Opt_scsd$fit$weights[[2]]!=0, arr.ind = T)
# which(Opt_scsd$fit$weights[[4]]!=0, arr.ind = T)
# Opt_gd <- fit_gammaFrailty(
#     DATA_LIST = list('DATA' = dt, 'X' = X),
#     METHOD = 'GD',
#     CPP_CONTROL = ctrl_gd,
#     VERBOSEFLAG= 0,
#     INIT = par_init,
#     ITERATIONS_SUBSET = trajSub
# )
# mean((repartopar(Opt_gd$theta)-theta)^2)
# sampleVar(
#     THETA = Opt_sgd$theta,
#     DATA = dt,
#     X = X,
#     NU = 1,
#     METHOD = 1,
#     RANGE = ctrl_scsd$MAXT-ctrl_scsd$BURN,
#     TOTFLAG = T,
#     PRINTFLAG = F
# )
#
# #### check hessian ####
# Rwrapper_ncl <- function(par){
#     ncl(par, dt, X)$nll
# }
# Rwrapper_ngr <- function(par){
#     ncl(par, dt, X)$ngradient
# }
#
# chosen_par <- Opt_sgd$fit$path_av_theta[1001,]#Opt_u$theta#par_init #
# chosen_par <- par_init
# chosen_par <- Opt_u$theta
#
# H <- sampleH(chosen_par, dt, X, INVERTFLAG = F)
# Hnum <- numDeriv::jacobian(Rwrapper_ngr, chosen_par)
# H2 <- H
# diag(H2) <- diag(Hnum)
# diag(H)
# diag(Hnum)
# Hnum %>% solve() %>% diag() %>% round(4)
# H2 %>% solve() %>% diag() %>% round(4)
# H %>% solve() %>% diag() %>% round(4)
#
# it <- 5000
# sgd_se <- sampleVar(
#     THETA = Opt_sgd$fit$path_av_theta[it,],
#     DATA = dt,
#     X = X,
#     NU = 1,
#     METHOD = 1,
#     RANGE = it-ctrl_scsd$BURN,
#     TOTFLAG = T,
#     PRINTFLAG = F
# )
#
# scsd_se <- sampleVar(
#     THETA = Opt_scsd$fit$path_av_theta[it,],
#     DATA = dt,
#     X = X,
#     NU = 1,
#     METHOD = 2,
#     RANGE = it-ctrl_scsd$BURN,
#     TOTFLAG = T,
#     PRINTFLAG = F
# )
# sgd_se$se$se_stoc
# scsd_se$se$se_stoc
#
# Hinv <- sampleH(Opt_scsd$fit$path_av_theta[it,], dt, X, INVERTFLAG = T)
# J <- sampleJ(Opt_scsd$fit$path_av_theta[it,], dt, X)
# (Hinv%*%J%*%Hinv/(it-ctrl_scsd$BURN)) %>% diag() %>% sqrt()
# (Hinv/(it-ctrl_scsd$BURN)) %>% diag() %>% sqrt()
# scsd_se$var$var_stoc %>% diag() %>% sqrt()
# H %>%  diag(); (scsd_se$var$var_stoc * (it-ctrl_scsd$BURN)) %>% diag()
# diag(J);diag(Hinv); diag(solve(Hinv))
gg <- get_tidy_path(Opt_sgd, 'path_av_theta', F) %>%
mutate( mod = 'SGD') %>%
bind_rows(
get_tidy_path(Opt_scsd, 'path_av_theta', F) %>%
mutate( mod = 'SCSD')
) %>%
mutate(
mse = map_dbl(path_av_theta, ~mean((.x-repar_theta)^2))
) %>%
ggplot( aes(x = iter, y = log(mse), col = mod))+
geom_line()+
geom_hline(yintercept = log(mean((Opt_u$theta-repar_theta)^2)), linetype = 'dashed')+
theme_minimal()
plotly::ggplotly(gg)
library(gammaFrailty)
library(gammaFrailty)
##################
#### libraries #####
library(tidyverse)
p <- 30
q <- 8
xi <- 2/q
rho <- .6
m <- 10
n <- 1000
int <- runif(p, -.5, .5)#rep(.5, p)#
b <- rnorm(m, 0, .5) #runif(m,0,.5)#rep(0, m) #
set.seed(1)
X <- matrix(rbinom(m*n, 1, .5), n, m)#matrix(runif(m*n, 0, 1), n, m)
theta <- c(xi, rho, b, int)
repar_theta <- partorepar(theta)
seed <- 3
##### generate the data ###
dt <- generate_data(
INTERCEPT = int,
BETA = b,
X = X,
Q = q,
RHO = rho,
SEED = seed
)
##### estimation ####
set.seed(1); par_init <- repar_theta + runif(length(repar_theta), -1, 1)
######## simulation test #######
set.seed(1); par_init <- repar_theta + runif(length(repar_theta), -1, 1)
Opt_u <- fit_gammaFrailty(
DATA_LIST = list('DATA' = dt, 'X' = X),
METHOD = 'ucminf',
CPP_CONTROL = list(),
#UCMINF_CONTROL = list('ctrl' = list(invhessian.lt = solve(H0)[lower.tri(H0,diag=TRUE)]), 'hessian' = 0),
VERBOSEFLAG= 0,
INIT = par_init,
ITERATIONS_SUBSET = NULL
)
library(tidyverse)
sim_settings <- expand_grid(
mod = c('SGD', 'SCSD'),
stepsize = c(1.25e-4, 2.5e-4, 5e-4),
stoc_seed = 1:5,
maxiter = 2000,
burn = 200
)
custom_est_fun <- function(MOD, STEPSIZE, SEED, MAXT, BURN){
ctrl <- list(
MAXT = MAXT,
BURN = BURN,
STEPSIZE = STEPSIZE,
NU = 1,
SEED = SEED
)
mod_obj <- fit_gammaFrailty(
DATA_LIST = list('DATA' = dt, 'X' = X),
METHOD = MOD,
CPP_CONTROL = ctrl,
VERBOSEFLAG= 0,
INIT = par_init,
ITERATIONS_SUBSET = NULL#trajSub
)
return(mod_obj)
}
#custom_est_fun(MOD = 'SGD', STEPSIZE=1.25e-4, SEED = 123, MAXT = 1000, BURN = 200)
est_tab <- sim_settings %>%
mutate(
mod_obj = pmap(
list(mod, stepsize, stoc_seed, maxiter, burn),
function(mod_, stepsize_, stoc_seed_, maxiter_, burn_){
custom_est_fun(
MOD = mod_,
STEPSIZE = stepsize_,
SEED = stoc_seed_,
MAXT = maxiter_,
BURN = burn_)
}
)
)
metrics_tab <- est_tab %>%
mutate(
path_av_theta = map(mod_obj, ~get_tidy_path(.x, 'path_av_theta', F)),
path_nll = map(mod_obj, ~get_tidy_path(.x, 'path_nll', F)),
path_grad = map(mod_obj, ~get_tidy_path(.x, 'path_grad', F))
) %>%
select(-mod_obj) %>%
mutate(
metrics = pmap(
list(path_av_theta, path_nll, path_grad),
function(path_av_theta_, path_nll_, path_grad_){
path_av_theta_ %>%
left_join(path_nll_, by = 'iter') %>%
left_join(path_grad_, by = 'iter')
}
)
) %>%
select(-c(path_av_theta, path_nll, path_grad)) %>%
unnest(c(metrics)) %>%
mutate(
mse = map_dbl(path_av_theta, ~mean((.x-repar_theta)^2)),
grad_norm = map_dbl(path_grad, ~norm(as.matrix(.x)))
) %>%
gather(key = 'performance', value = 'val', path_nll, grad_norm, mse)
########
name_par <- function(par){
if(par == 1)
'xi'
else if(par == 2)
'correlation'
else if(par %in% 3:(2+m))
'regression coefficients'
else
'intercepts'
}
true_tib <- tibble(
par = 1:length(repar_theta), true_val = repar_theta
) %>%
mutate(
par_type = map_chr(par, ~name_par(.x)),
par = as.factor(par))
num_tib <- tibble(
par = 1:length(repar_theta), num_val = Opt_u$theta
)%>%
mutate(
par_type = map_chr(par, ~name_par(.x)),
par = as.factor(par))
par_tab <- est_tab %>%
mutate(
path_av_theta = map(mod_obj, ~get_tidy_path(.x, 'path_av_theta', F))
) %>%
unnest(c(path_av_theta)) %>%
mutate(
path_av_theta = lapply(path_av_theta, function(x){
tib <- tibble(
par = 1:length(x),
val = x
)
tib
})
) %>%
unnest(c(path_av_theta)) %>%
mutate(
par_type = map_chr(par, ~name_par(.x)),
par = as.factor(par)
)
gg <- par_tab  %>%
# mutate(
#     val = map2_dbl(par, val, ~if(.x==2){rofz_cpp(.y)}else{.y}),
#     val = map2_dbl(par, val, ~if(.x==1){exp(-.y)}else{.y})
# ) %>%
ggplot(aes(x = iter, y = val))+
geom_line(aes(linetype = mod,  col = factor(stepsize), group = interaction(mod, stepsize, stoc_seed, par))) +
geom_point(data = num_tib, aes(x = 2000, y = num_val), col = 'red', shape = 4, size = 2)+
geom_point(data = true_tib, aes(x = 2020, y = true_val), col = 'blue', shape = 4, size = 2)+
facet_wrap(vars(par_type), scales = 'free') +
theme_bw()+
scale_color_viridis_d()
gg
library(gammaFrailty)
#### libraries #####
library(tidyverse)
##################
#### libraries #####
library(tidyverse)
p <- 30
q <- 8
xi <- 2/q
rho <- .6
m <- 10
n <- 1000
int <- runif(p, -.5, .5)#rep(.5, p)#
b <- rnorm(m, 0, .5) #runif(m,0,.5)#rep(0, m) #
set.seed(1)
X <- matrix(rbinom(m*n, 1, .5), n, m)#matrix(runif(m*n, 0, 1), n, m)
theta <- c(xi, rho, b, int)
repar_theta <- partorepar(theta)
seed <- 3
##### generate the data ###
dt <- generate_data(
INTERCEPT = int,
BETA = b,
X = X,
Q = q,
RHO = rho,
SEED = seed
)
##### estimation ####
set.seed(1); par_init <- repar_theta + runif(length(repar_theta), -1, 1)
ctrl_gd <- list(MAXT = n^.75,     STEPSIZE = .001)
trajSub <- c(50, 100, 500, 1000)
trajSub <- c(750, 1000, 2000, 3000, 5000, 7500, 10000)
mean((par_init-repar_theta)^2)
H0 <- sampleH(THETA = par_init, DATA = dt, X = X, F, F)
Opt_u <- fit_gammaFrailty(
DATA_LIST = list('DATA' = dt, 'X' = X),
METHOD = 'ucminf',
CPP_CONTROL = list(),
#UCMINF_CONTROL = list('ctrl' = list(invhessian.lt = solve(H0)[lower.tri(H0,diag=TRUE)]), 'hessian' = 0),
VERBOSEFLAG= 0,
INIT = par_init,
ITERATIONS_SUBSET = NULL
)
mean((Opt_u$theta-repar_theta)^2)
sgd_var <- sampleVar(
THETA = repar_theta,
DATA = dt,
X = X,
NU = 1,
METHOD = 2,
RANGE = ctrl_scsd$MAXT-ctrl_scsd$BURN,
TOTFLAG = T,
PRINTFLAG = F
)
ctrl_sgd <- list(
MAXT = 1000,
BURN = 200,
STEPSIZE = 0.0001265499,
#STEPSIZE0 = .0005,
NU = 1,
SEED = seed
)
Opt_sgd <- fit_gammaFrailty(
DATA_LIST = list('DATA' = dt, 'X' = X),
METHOD = 'SGD',
CPP_CONTROL = ctrl_sgd,
VERBOSEFLAG= 0,
INIT = par_init,
ITERATIONS_SUBSET = NULL#trajSub
)
#mean((repartopar(Opt_sgd$theta)-theta)^2)
mean((Opt_sgd$theta-repar_theta)^2)
#Opt_sgd$fit$path_av_theta
dim(Opt_sgd$fit$path_theta)
length(Opt_sgd$fit$path_nll)
Rwrapper_ncl(Opt_sgd$theta_init)
Rwrapper_ncl(Opt_sgd$theta)
ctrl_scsd <- list(
MAXT = 1000,
BURN = 200,
STEPSIZE = 5e-4,
#STEPSIZE0 = .0005,
NU = 1,
SEED = seed
)
Opt_scsd <- fit_gammaFrailty(
DATA_LIST = list('DATA' = dt, 'X' = X),
METHOD = 'SCSD',
CPP_CONTROL = ctrl_scsd,
VERBOSEFLAG= 0,
INIT = par_init,
ITERATIONS_SUBSET = NULL
)
#mean((repartopar(Opt_scsd$theta)-theta)^2)
mean((Opt_scsd$theta-repar_theta)^2)
Opt_scsd$fit
# sgd_se$se$se_stoc
# scsd_se$se$se_stoc
#
# Hinv <- sampleH(Opt_scsd$fit$path_av_theta[it,], dt, X, INVERTFLAG = T)
# J <- sampleJ(Opt_scsd$fit$path_av_theta[it,], dt, X)
# (Hinv%*%J%*%Hinv/(it-ctrl_scsd$BURN)) %>% diag() %>% sqrt()
# (Hinv/(it-ctrl_scsd$BURN)) %>% diag() %>% sqrt()
# scsd_se$var$var_stoc %>% diag() %>% sqrt()
# H %>%  diag(); (scsd_se$var$var_stoc * (it-ctrl_scsd$BURN)) %>% diag()
# diag(J);diag(Hinv); diag(solve(Hinv))
lab <- 'path_av_theta'
gg <- get_tidy_path(Opt_sgd, lab, F) %>%
mutate( mod = 'SGD') %>%
bind_rows(
get_tidy_path(Opt_scsd, lab, F) %>%
mutate( mod = 'SCSD')
) %>%
mutate(
mse = map_dbl(path_av_theta, ~mean((.x-repar_theta)^2))
) %>%
ggplot( aes(x = iter, y = log(mse), col = mod))+
geom_line()+
geom_hline(yintercept = log(mean((Opt_u$theta-repar_theta)^2)), linetype = 'dashed')+
theme_bw()+
scale_color_viridis_d()
library(tidyverse)
